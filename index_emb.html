<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>2DCLIP</title>
    <script src="enable-threads.js"></script>
    <script src="./vips/vips.js"></script>
    <script src="umap-js.min.js"></script>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="stylesheet" href="2dclip.css">
    
  </head>
  <body>
    
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.12.0/dist/ort.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.17.0/dist/tf.min.js"></script> <!-- NOTE: tfjs is currently only used for image preprocessing stuff. -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js" integrity="sha512-csNcFYJniKjJxRWRV1R7fvnXrycHP6qDR21mgz1ZP55xY5d+aHLfo9/FcGDQLfn2IfngbAHd8LdfsagcCqgTcQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->

    <!-- <script src="https://cdn.jsdelivr.net/npm/pixi.js@5.3.4/dist/pixi.min.js"></script> -->

    
    <!-- <div class="absblock"> -->
      <!-- <script>
        if(Date.now() < 1648725949710+1000*60*60*24*365) { // display until start of April 2023
          browserCompatibilityWarning.style.display = "";
        }
      </script> -->
      <!-- <hr> -->

      <div id="downloadingProgressBars" style="display:none">
        Loading image model: <span id="imageModelLoadingMbEl"></span> <progress id="imageModelLoadingProgressBarEl" value="0"></progress> 
        <br>
        Loading text model: <span id="textModelLoadingMbEl"></span> <progress id="textModelLoadingProgressBarEl" value="0"></progress> 
       </div>

      <div id="step1">
        <h1>2D-CLIP</h1>

        <p>2D-CLIP lets you sort images using textual descriptions in two dimensions. 
        </p><p class="smallhelp">
          All images (and the neural network) remain on your computer and are never sent to a server.
          <br>
         For more information see the <a href="https://github.com/leoimpett/2dclip" target="_blank">Github page</a>.
         <br>
        To get started, hit 'Load folder' below. </p> 


        Model:
     <select onchange="window.MODEL_NAME=this.value;" style="width:100px">
       <option value="clip_vit_32">CLIP ViT-B/32 (recommended)</option>
       <option value="clip_vit_32_uint8">CLIP ViT-B/32 (quantized - inaccurate embeddings)</option>
       <option value="lit_b16b">LiT B16B</option>
     </select>
     <br><br>
     <button  onclick="doAll()">Load folder</button>
     <br>
     <br>
     <button onclick="document.getElementById('helpText').style.display='block'; this.style.opacity=0.5;">Help! I don't have a folder of images</button>
     <br><br>
     <span id="helpText" style="display:none">Click <a href="./fitzwilliam_thumbs.zip">here</a> for a dataset to get you started. You might also try <a href="https://datasetsearch.research.google.com/" target="_blank">Google Dataset Search</a>, or going to a museum website and downloading all the images with a <a href="https://chrome.google.com/webstore/detail/image-downloader/cnpniohnfphhjihaiiggeabnkjhpaldj?hl=en-US" target="_blank"> browser extension</a>.
     </span>


   </div>



      
      <!-- <div id="" style="padding:0.5rem; background:lightgrey; margin:0.5rem;">      </div> -->
        <!-- Choose model: -->

        <!-- <button id="initWorkersBtn" onclick="initializeWorkers()">[1]</button>
        <button id="pickDirectoryBtn" onclick="pickDirectory({source:'local'})">[2]</button> 
        <button id="computeEmbeddingsBtn" onclick="computeImageEmbeddings(); this.disabled=true;">[3]</button> -->
      
          <div >

          <div id="step2" class="grow" style="display:none">

          <h2>CLIP-2D</h2>

          <hr>
          <h3>Plot</h3>

            <p class="smallhelp">Enter any two search terms in the fields below - the similarity between the image and the term will control the position of the image. You can try concrete terms or abstract concepts. </p>
            <!-- <br><br> -->
        X: <input id="searchTextEl" style="width:100px;" value="" placeholder="Symmetry" onkeyup="if(event.which==13) searchSort()">
        <br>
        Y: <input id="searchTextEl2" style="width:100px;" value="" placeholder="Sculpture" onkeyup="if(event.which==13) searchSort()">
        <br>
        <button id="searchBtn" onclick="searchSort()">Plot</button>
        <br>
        <button id="screenshot" onclick="getCSV()">Download similarities</button>


        <hr>
        <h3>Visualize</h3>

        Image size: <input type="range" id="imsizeslider" >
        <!-- check button for force directed -->
        <br>
        Force separation:
        <input type="checkbox" id="forceDirected" checked>
        <br>
        Hide toolbar:
        <input type="checkbox" id="hideToolbar" >
        <hr>
        <h3>Image Processing</h3>
        <!-- <br> -->
        <div id="existingEmbeddingsFoundCtnEl" >
          <button id="changeFolder" onclick="pickDirectory({source:'local'});computeImageEmbeddings();clearD3()">Change folder</button>
          <br>
          <button onclick="computeImageEmbeddings()">Reload images</button>
          <br><br>
         <!-- Ignore preprocessed images:  -->
         <input id="onlyEmbedNewImagesCheckbox" type="checkbox" checked  style="display:none" >
       </div>
       <span id="preexistingEmbeddingsEl" class="smallhelp"></span>
       <div id="computedEmbeddings" class="smallhelp">
        <span id="computeEmbeddingsProgressEl">0</span> of <span id="totalNumberImages">0</span> ims (<span id="computeEmbeddingsSpeedEl">?</span> ms/im). 
        <progress id="computeEmbeddingsLoadingProgressBarEl" value="0"></progress>
        <p class="smallhelp">Still loading images, but feel free to enter some text in the axes above and hit enter.</p>
       </div>

       <!-- <p>To change folder, just reload this page. </p> -->
        </div>

      </div>




      
      <div id="initCtnEl" style="padding:0.5rem; background:lightgrey; margin:0.5rem; display:none">
        <b>Step 2:</b> Download and initialize the models.
        <br>

        <br>
        Initialize workers: <progress id="workerInitProgressBarEl" value="0"></progress>
        <div style="display:none;"> <!-- more workers (dividing threads between them) doesn't seem to make things faster -->
          Number of image embedding workers/threads: <input id="numThreadsEl" type="range" min="1" max="4" value="1" oninput="numThreadsDisplayEl.textContent=this.value"> <span id="numThreadsDisplayEl"></span> <script>numThreadsEl.max = navigator.hardwareConcurrency; numThreadsDisplayEl.textContent=numThreadsEl.value;</script>
        </div>
        <br>
      </div>

      <div id="pickDirCtnEl" style="opacity:0.5; pointer-events:none; padding:0.5rem; background:lightgrey; margin:0.5rem;display:none">
        <b>Step 3:</b> Pick a directory of images (images in subdirectories will be included).
        <br>
&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp; <button id="useRedditImagesBtn" onclick="pickDirectory({source:'reddit'})">use ~200k reddit images</button> (remove nsfw:<input id="removeRedditNsfwEl" type="checkbox" checked>)
        <br>
        <div id="redditLoadProgressCtn" style="display:none;">Download progress: <progress id="redditProgressBarEl" value="0"></progress> <span id="redditProgressMbEl"></span></div>
        <div id="existingEmbeddingsProgressCtn" style="display:none;">Loading existing embeddings: <span id="existingEmbeddingsLoadedEl">none</span></div>
      </div>
      
      <!-- <div id="computeEmbeddingsCtnEl" style="opacity:0.5; pointer-events:none; padding:0.5rem; background:lightgrey; margin:0.5rem;display:none">
        <b>Step 4:</b> Compute image embeddings. <span style="opacity:0.5;">(they will be saved as &lt;ModelName&gt;_embeddings.tsv in the selected directory)</span>
        <br>

      </div> -->



      <div id="searchCtnEl" style="opacity:0.5; pointer-events:none; padding:0.5rem; background:lightgrey; margin:0.5rem;display:none">
        <b>Step 6:</b> Enter a search term.
        <br>
      </div>
    <!-- </div> -->

    <!-- <hr> -->
    <!-- <b>Results</b> <span style="opacity:0.5;">(hover for cosine similarities)</span> -->
    <div id="resultsEl" style="margin-top:1rem; min-height:100vh; display:none"><span style="opacity:0.5;">Click the search button to compute the results.</span></div>
    
    <!-- <canvas id="canvas" width="1000" height="1000" style="border:1px solid black;"></canvas> -->

    <div id="map-container" style="height:100%; width:100%;"></div>
    <div id="x-axis-label"></div>
    <div id="y-axis-label"></div> 


            <!-- add here a little loading css spinner -->
            <div id="searchSpinner" class="loader"> </div>




    <script>
      /////////////
      //  STEP 1 //
      /////////////

      var workersInitialised = false; // will be set to true after workers are initialized


      var maxNImages = 6000;

      // doAll function
      function doAll() {


        // initialize workers
        if (!workersInitialised){initializeWorkers();}
        

        // pick directory
          pickDirectory({source:'local'});
          console.log("directory picked")
  
      }
      

      // first we need to download the models and initialize the workers 
      window.MODEL_NAME = "clip_vit_32";
      window.modelData = {
        clip_vit_32: {
          image: {
            modelUrl: (quantized) => `https://huggingface.co/rocca/openai-clip-js/resolve/main/clip-image-vit-32-${quantized ? "uint8" : "float32"}.onnx`,
            embed: async function(blob, session) {
              let rgbData = await getRgbData(blob);
              const feeds = {input: new ort.Tensor('float32', rgbData, [1,3,224,224])};
              const results = await session.run(feeds);
              const embedVec = results["output"].data; // Float32Array
              return embedVec;
            }
          },
          text: {
            modelUrl: (quantized) => `https://huggingface.co/rocca/openai-clip-js/resolve/main/clip-text-vit-32-${quantized ? "uint8" : "float32-int32"}.onnx`,
            embed: async function(text, session) {
              if(!window.textTokenizerClip) {
                let Tokenizer = (await import("https://deno.land/x/clip_bpe@v0.0.6/mod.js")).default;
                window.textTokenizerClip = new Tokenizer(); 
              }
              let textTokens = window.textTokenizerClip.encodeForCLIP(text);
              textTokens = Int32Array.from(textTokens);
              const feeds = {input: new ort.Tensor('int32', textTokens, [1, 77])};
              const results = await session.run(feeds);
              return [...results["output"].data];
            },
          }
        },
        lit_b16b: {
          image: {
            modelUrl: () => 'https://huggingface.co/rocca/lit-web/resolve/main/embed_images.onnx',
            embed: async function(blob, session) {
              
              // TODO: Maybe remove tf from this code so you can remove the whole tfjs dependency
              blob = await bicubicResizeAndCenterCrop(blob);
              let inputImg = new Image();
              await new Promise(r => inputImg.onload=r, inputImg.src=URL.createObjectURL(blob));
              let img = tf.browser.fromPixels(inputImg);
              img = tf.sub(tf.div(tf.expandDims(img), 127.5), 1);
              let float32RgbData = img.dataSync();
              
              const feeds = {'images': new ort.Tensor('float32', float32RgbData, [1,224,224,3])};
              const results = await session.run(feeds);
              return results["Identity_1:0"].data;
            },
          },
          text: {
            modelUrl: () => 'https://huggingface.co/rocca/lit-web/resolve/main/embed_text_tokens.onnx',
            embed: async function(text, session) {
              // Here we use a custom tokenizer that is not part of the model
              if(!window.bertTextTokenizerLit) {
                window.bertTextTokenizerLit = await import("./bert-text-tokenizer.js").then(m => new m.BertTokenizer());
                await window.bertTextTokenizerLit.load();
              }
              let textTokens = window.bertTextTokenizerLit.tokenize(text);
              textTokens.unshift(101); // manually put CLS token at the start
              textTokens.length = 16;
              textTokens = [...textTokens.slice(0, 16)].map(e => e == undefined ? 0 : e); // pad with zeros to length of 16
              textTokens = Int32Array.from(textTokens);
              const feeds = {'text_tokens': new ort.Tensor('int32', textTokens, [1,16])};
              const results = await session.run(feeds);
              return [...results["Identity_1:0"].data];
            }
          }
        },
      };

      let imageWorkers = [];
      let onnxImageSessions = [];
      let onnxTextSession;
      let textTokenizer;
      async function initializeWorkers() {

        workersInitialised = true; 

        console.log("initialising workers")


        // show downloadingProgressBars
        document.getElementById("downloadingProgressBars").style.display = "block";
        console.log('showing progressbar')


        // initWorkersBtn.disabled = true;
        numThreadsEl.disabled = true;
        
        let useQuantizedModel = false;
        
        if(MODEL_NAME.endsWith("_uint8")) {
          MODEL_NAME = MODEL_NAME.replace(/_uint8$/g, "");
          useQuantizedModel = true;
        }
        
        let imageOnnxBlobPromise = downloadBlobWithProgress(window.modelData[MODEL_NAME].image.modelUrl(useQuantizedModel), function(e) {
          let ratio = e.loaded / e.total;
          imageModelLoadingProgressBarEl.value = ratio;
          imageModelLoadingMbEl.innerHTML = Math.round(ratio*e.total/1e6)+" MB";
        });

        let textOnnxBlobPromise = downloadBlobWithProgress(window.modelData[MODEL_NAME].text.modelUrl(useQuantizedModel), function(e) {
          let ratio = e.loaded / e.total;
          textModelLoadingProgressBarEl.value = ratio;
          textModelLoadingMbEl.innerHTML = Math.round(ratio*e.total/1e6)+" MB";
        });

        let [imageOnnxBlob, textOnnxBlob] = await Promise.all([imageOnnxBlobPromise, textOnnxBlobPromise])
        console.log("Blob sizes: ", imageOnnxBlob.size, textOnnxBlob.size);

        let imageModelUrl = window.URL.createObjectURL(imageOnnxBlob);
        let textModelUrl = window.URL.createObjectURL(textOnnxBlob);

        // console.log("URLs: ", imageModelUrl, textModelUrl);
        
        let numImageWorkers = Number(numThreadsEl.value);
        
        // Inference latency is about 5x faster with wasm threads, but this requires these headers: https://web.dev/coop-coep/ I'm using this as a hack (in enable-threads.js) since Github pages doesn't allow setting headers: https://github.com/gzuidhof/coi-serviceworker
        if(self.crossOriginIsolated) {
          ort.env.wasm.numThreads = Math.ceil(navigator.hardwareConcurrency / numImageWorkers) / 2; // divide by two to utilise only half the CPU's threads because trying to use all the cpu's threads actually makes it slower
        }

        workerInitProgressBarEl.max = numImageWorkers + 2; // +2 because of text model and bpe library
        
        let imageModelExecutionProviders = ["wasm"]; // webgl is not compatible with this model (need to tweak conversion data/op types)

        for(let i = 0; i < numImageWorkers; i++) {
          let session = await ort.InferenceSession.create(imageModelUrl, { executionProviders: imageModelExecutionProviders }); 
          onnxImageSessions.push(session);
          imageWorkers.push({
            session,
            busy: false,
          });
          workerInitProgressBarEl.value = Number(workerInitProgressBarEl.value) + 1;
        }
        console.log("Image model loaded.");

        onnxTextSession = await ort.InferenceSession.create(textModelUrl, { executionProviders: ["wasm"] }); // webgl is not compatible with this model (need to tweak conversion data/op types)
        console.log("Text model loaded.");
        workerInitProgressBarEl.value = Number(workerInitProgressBarEl.value) + 1;

        window.URL.revokeObjectURL(imageModelUrl);
        window.URL.revokeObjectURL(textModelUrl);

        window.vips = await Vips(); // for bicubicly resizing images (since that's what CLIP expects)
        window.vips.EMBIND_AUTOMATIC_DELETELATER = false;

        workerInitProgressBarEl.value = Number(workerInitProgressBarEl.value) + 1;

        // disableCtn(initCtnEl);
        // enableCtn(pickDirCtnEl);

        // hide searchSpinner
        document.getElementById("searchSpinner").style.display = "none";


        // hide downloadingProgressBars
        document.getElementById("downloadingProgressBars").style.display = "none";
        console.log('hiding progressbar')

        


      }


      /////////////
      //  STEP 2 //
      /////////////
      let directoryHandle;
      let embeddingsFileHandle;
      let embeddings;
      let dataSource;
      async function pickDirectory(opts={}) {
        dataSource = opts.source;
         
        if(dataSource === "local") {
          if(!window.showDirectoryPicker) return alert("Your browser does not support some modern features (specifically, File System Access API) required to use this web app. Please try updating your browser, or switching to Chrome, Edge, or Brave.");
          directoryHandle = await window.showDirectoryPicker();
          embeddingsFileHandle = await directoryHandle.getFileHandle(`${window.MODEL_NAME}_embeddings.tsv`, {create:true});
          
          // pickDirectoryBtn.disabled = true;
          // useRedditImagesBtn.disabled = true;
          // pickDirectoryBtn.textContent = "Loading...";

        }
        
        let redditEmbeddingsBlob;
        try {
          existingEmbeddingsProgressCtn.style.display = "";
          
          embeddings = {};
          let file, opts;
          if(dataSource === "local") {
            file = await embeddingsFileHandle.getFile();
            opts = {}; 
          }
          if(dataSource === "reddit") {
            file = redditEmbeddingsBlob;
            opts = {decompress:"gzip"};
          }
          
          let i = 0;
          for await (let line of makeTextFileLineIterator(file, opts)) {
            if(!line || !line.trim()) continue; // <-- to skip final new line (not sure if this is needed)
            let [filePath, embeddingVec] = line.split("\t");
            embeddings[filePath] = JSON.parse(embeddingVec);
            i++;
            if(i % 1000 === 0) {
              existingEmbeddingsLoadedEl.innerHTML = i;
              await sleep(10);
            }
          }
        } catch(e) {
          embeddings = undefined;
          console.log("No existing embedding found, or the embeddings file was corrupted:", e);
          existingEmbeddingsProgressCtn.style.display = "none";
        }
        
        // pickDirectoryBtn.textContent = "Done.";
        // useRedditImagesBtn.textContent = "Done.";

        // disableCtn(pickDirCtnEl);
        // enableCtn(computeEmbeddingsCtnEl);
        // enableCtn(searchCtnEl);

          // hide #step1
          document.getElementById("step1").style.display = "none";
          // show #step2
          document.getElementById("step2").style.display = "block";
          // Set step2 class to hover 
          document.getElementById("step2").classList.add("hover");
          // Set timeout to remove hover class 
          setTimeout(function(){
            document.getElementById("step2").classList.remove("hover");
          }, 2000);

        // if(embeddings && Object.keys(embeddings).length > 0) {
        //   computeEmbeddingsCtnEl.style.display = "none";
        //   existingEmbeddingsFoundCtnEl.style.display = "";
        // }
        
        // if(dataSource === "reddit") {
        //   disableCtn(existingEmbeddingsFoundCtnEl);
        // }


        // show searchSpinner
        document.getElementById("searchSpinner").style.display = "block";

        

          //  The end of pickdirectory - is always going to be....
          // Wait until window.vips is defined
          while (window.vips === undefined) {
            // console.log("waiting for vips")
            await sleep(100);
          }
          computeImageEmbeddings() // <-- this is the end of pickdirectory


      }
      

      /////////////
      //  STEP 3 //
      /////////////
      let totalEmbeddingsCount = 0;
      let imagesEmbedded;
      let recentEmbeddingTimes = []; // how long each embed took in ms, newest at end
      let recomputeAllEmbeddings;
      let imagesBeingProcessedNow = 0;
      let needToSaveEmbeddings = false;
      async function computeImageEmbeddings() {

        // show computedEmbeddings

        console.log("Computing image embeddings...");
        imagesEmbedded = 0;
        totalEmbeddingsCount = Object.keys(embeddings).length;

        recomputeAllEmbeddings = !onlyEmbedNewImagesCheckbox.checked;
        let gotSomeExistingEmbeddings = totalEmbeddingsCount > 0;

        // Try: if not gotSomeExistingEmbeddings, then force recomputeAllEmbeddings to be true
        if (!gotSomeExistingEmbeddings) {
          console.log("forcing recompute")
          recomputeAllEmbeddings = true;
        }
        
        if(onlyEmbedNewImagesCheckbox.checked && gotSomeExistingEmbeddings) {
          preexistingEmbeddingsEl.innerHTML = `Loaded ${Object.keys(embeddings).length} preprocessed images.`; 
          // hide computedEmbeddings 
          document.getElementById("computedEmbeddings").style.display = "none";
        }
        else {
          document.getElementById("computedEmbeddings").style.display = "block";
        }

        if(recomputeAllEmbeddings || !gotSomeExistingEmbeddings) {
          embeddings = {}; // <-- maps file path (relative to top/selected directory) to embedding
        }

        console.log(recomputeAllEmbeddings, gotSomeExistingEmbeddings, Object.keys(embeddings).length)
        
        try {
          await recursivelyProcessImagesInDir(directoryHandle);
          await saveEmbeddings();
        } catch(e) {
          console.error(e);
          alert(e.message);
        }

        // disableCtn(computeEmbeddingsCtnEl);
        // enableCtn(searchCtnEl);

        // hide loading spinner
        document.getElementById("searchSpinner").style.display = "none";

      }


      async function recursivelyProcessImagesInDir(dirHandle, currentPath="") {


            // image count first!!! 
                  let imageCount = 0;

                // Count the number of image files
                for await (let [name, handle] of dirHandle) {
                  const {kind} = handle;
                  let path = `${currentPath}/${name}`;
                  if (handle.kind === 'directory') {
                    imageCount += await recursivelyProcessImagesInDir(handle, path);
                  } else {
                    // make lower case copy of path
                    let pathLower = path.toLowerCase();

                    let isImage = /\.(png|jpg|jpeg|webp|JPEG|JPG)$/.test(pathLower);
                    if(!isImage) continue;

                    imageCount++;
                  }
                }

                // Print the total number of image files
                console.log(`Total number of image files: ${imageCount}`);

                // If imageCount > maxNImages, then alert
                if (imageCount > maxNImages) {
                  alert(`You have selected a directory with ${imageCount} images. This is more than the maximum number of images recommended (1000).`);
                }


                // set innerhtml of totalNumberImages to imageCount 
                document.getElementById("totalNumberImages").innerHTML = imageCount;



        for await (let [name, handle] of dirHandle) {
          const {kind} = handle;
          let path = `${currentPath}/${name}`;
          if (handle.kind === 'directory') {
            await recursivelyProcessImagesInDir(handle, path);
          } else {
            // make lower case copy of path
            let pathLower = path.toLowerCase();


            let isImage = /\.(png|jpg|jpeg|webp|JPEG|JPG)$/.test(pathLower);
            if(!isImage) continue;

            // console.log("Processing image:", path)

            let alreadyGotEmbedding = !!embeddings[path];

            // console.log("Alreadygotembedding:",alreadyGotEmbedding)
            // console.log("Recompute:", recomputeAllEmbeddings)
            // console.log("needToSaveEmbeddings:", needToSaveEmbeddings)

            if(alreadyGotEmbedding && !recomputeAllEmbeddings) continue;
            
            if(needToSaveEmbeddings) {
              await saveEmbeddings();
              needToSaveEmbeddings = false;
            }
              
            while(imageWorkers.filter(w => !w.busy).length === 0) await sleep(1);
            
            let worker = imageWorkers.filter(w => !w.busy)[0];
            worker.busy = true;
            imagesBeingProcessedNow++;
            
            // if (Object.keys(embeddings).length >= maxNImages){continue}
            

            (async function() {
              let startTime = Date.now();
              
              let blob = await handle.getFile();
              const embedVec = await modelData[MODEL_NAME].image.embed(blob, worker.session);

              embeddings[path] = [...embedVec];
              worker.busy = false;

              imagesEmbedded++;
              totalEmbeddingsCount++;
              
              

              // console.log(`Embedded ${Object.keys(embeddings).length} images in ${Date.now() - startTime} ms`);

              computeEmbeddingsProgressEl.innerHTML = Object.keys(embeddings).length;

              // Update computeEmbeddingsLoadingProgressBarEl with the ratio of imagesEmbedded to imageCount
              computeEmbeddingsLoadingProgressBarEl.value = Object.keys(embeddings).length / imageCount;
              // Make sure that the progress bar is visible
              document.getElementById("computedEmbeddings").style.display = "block";

              // If the ratio is not one, set step2 to :hover. Else remove :hover
              // maybe get rid of this
              // if ((Object.keys(embeddings).length < imageCount)&&(Object.keys(embeddings).length < maxNImages)){
              //   document.getElementById("step2").classList.add("hover");
              // } else {
              //   document.getElementById("step2").classList.remove("hover"); 
              // }

              

              
              let saveInterval = totalEmbeddingsCount > 50_000 ? 10_000 : 1000; // since saves take longer if there are lots of embeddings
              if(imagesEmbedded % saveInterval === 0) {
                needToSaveEmbeddings = true;
              }
              
              recentEmbeddingTimes.push(Date.now()-startTime);
              if(recentEmbeddingTimes.length > 100) recentEmbeddingTimes = recentEmbeddingTimes.slice(-50);
              if(recentEmbeddingTimes.length > 10) computeEmbeddingsSpeedEl.innerHTML = Math.round(recentEmbeddingTimes.slice(-20).reduce((a,v) => a+v, 0)/20);

              imagesBeingProcessedNow--;
            })();


          }
        }
        while(imagesBeingProcessedNow > 0) await sleep(10);
      }
      

      /////////////
      //  STEP 4 //
      /////////////
      async function searchSort() {
        searchBtn.disabled = true;
        // searchSpinner show
        document.getElementById("searchSpinner").style.display = "inline-block";
        
        if(dataSource === "local") {
          for(let imgEl of [...document.querySelectorAll("img")]) {
            URL.revokeObjectURL(imgEl.src);
          }
        }
        
        resultsEl.innerHTML = "Loading...";
        await sleep(50);


        dataArray = [];
        for(let [path, embedding] of Object.entries(embeddings)) {
          // similarities[path] = cosineSimilarity(searchTextEmbedding, embedding);
          dataArray.push(embedding);
        }

        const umap = new UMAP({minDist:.2});
        // const umap = new UMAP({distanceFn:"cosine"});
        // Cosine distance doesn't seem to be working - check again some other time. 
        const umap_embedding = umap.fit(dataArray);

        imageResults = [];
        for(let [path, embedding] of Object.entries(embeddings)) {
          // index 
          i = Object.keys(embeddings).indexOf(path);
           score = umap_embedding[i][0]
           score2 = umap_embedding[i][1]
           let handle = await getFileHandleByPath(path);
            let url = URL.createObjectURL(await handle.getFile());
            imageResults.push({url, score, score2});
          }

        // imResult

        
        let resultHtml = "";
        let numResults = 0;


        const imageData = [];

        const container = d3.select("#map-container");

        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;

          // Get the minimum and maximum values of score and score2
          const [minScore, maxScore] = d3.extent(imageResults, d => d.score);
          const [minScore2, maxScore2] = d3.extent(imageResults, d => d.score2);

          // Create a linear scale for score and score2
          const scaleScore = d3.scaleLinear()
            .domain([minScore, maxScore])
            .range([0, 1]);

          const scaleScore2 = d3.scaleLinear()
            .domain([minScore2, maxScore2])
            .range([0, 1]);


        container
          .style("width", `${width}px`)
          .style("height", `${height}px`);

          for (let i = 0; i < imageResults.length; i++) {
          imageData.push({
            x: scaleScore(imageResults[i].score) * width ,
            y: height - (scaleScore2(imageResults[i].score2) * height),
            score: imageResults[i].score,
            score2: imageResults[i].score2,
            url: imageResults[i].url,
            // also save the title as the end bit of the url
            title: imageResults[i].url.split("/").slice(-1)[0],
            radius:20
          });
        }

        console.log(imageResults[0].score)
        console.log(scaleScore(imageResults[0].score))
        console.log([minScore, maxScore])
        console.log(imageData[0])
        // First remove existing svg from container
        container.selectAll("svg").remove();


        var imSize = 30;

        // If there are lots of images, reduce the imsize
        if (imageData.length > 600) {
          imSize = 20;
        }
        if (imageData.length > 1000) {
          imSize = 10;
        }

        const svg = container
          .append("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("width", width)
          .attr("height", height)
          .attr("id", "clip-svg");

          // Try force directed layout

          // Save the old (x,y) pairs as orig_x and orig_y
          for (let i = 0; i < imageData.length; i++) {
            imageData[i].orig_x = imageData[i].x;
            imageData[i].orig_y = imageData[i].y;
          }


          const minDistance = imSize/2;

          // create a force-directed layout with repulsion, attraction, and collision forces
          const simulation = d3.forceSimulation(imageData)
            // .force('repulsion', d3.forceManyBody().strength(-10))
            // .force('attraction', d3.forceRadial().radius(100).strength(0.1))
            // .force('collision', d3.forceCollide().radius(d => minDistance + d.radius))
            .force('collision', d3.forceCollide().radius(minDistance))
            // .force("gravity", d3.forceRadial(width / 2, height / 2, 50).strength(0.01))
            // add any other forces or constraints as needed
            .stop();

          // run the simulation for a set number of iterations
          for (let i = 0; i < 100; i++) {
            simulation.tick(); 
          }

          // Save the new simulation (x,y) pairs as force_x, force_y

          for (let i = 0; i < imageData.length; i++) {
            imageData[i].force_x = imageData[i].x;
            imageData[i].force_y = imageData[i].y;
          }


          // // Draw the points
          // circles = svg.selectAll('circle')
          //   .data(imageData)
          //   .enter()
          //   .append('circle')
          //   .attr('cx', d => (d.x + Math.random() * 0))
          //   .attr('cy', d => (d.y + Math.random() * 0))
          //   .attr('r', 5)
          //   .attr('fill', d => {
          //     const redValue =  scaleScore(d.score)*255;
          //     const blueValue =  scaleScore2(d.score2)*255;
          //     // console.log(redValue, 0, blueValue)
          //     // console.log(d.score)
          //     // console.log(scaleScore(d.score))
          //     return d3.rgb(redValue, 0, blueValue);
          //   })
          //   .attr('opacity', 0.3);

            // Add a slider to change the image size
            const slider = d3.select("#imsizeslider")
                .attr("min", 5)
                .attr("max", 50)
                .attr("step", 1)
                .attr("value", imSize);

              slider.on("input", function(event) {
                imSize = event.target.value;
                images.attr("width", imSize)
                      .attr("height", imSize);
              });

              // add checkbox forceDirected 
              const forceDirected = d3.select("#forceDirected")
              forceDirected.on("change", function(event) {
                if (event.target.checked) {
                  // console.log("checked")
                  // console.log(imageData[0])
                  // console.log(imageData[0].force_x)
                  // console.log(imageData[0].force_y)
                  images.attr("x", d => d.force_x)
                        .attr("y", d => d.force_y);
                } else {
                  // console.log("unchecked")
                  images.attr("x", d => d.orig_x)
                        .attr("y", d => d.orig_y);
                }
              });


                // X axis label
                const xAxisLabel = document.querySelector("#x-axis-label");
                if (xAxisLabel) {
                  xAxisLabel.innerHTML = searchTextEl.value + " →";
                  xAxisLabel.className = "axis-label";
                }

                // Y axis label
                const yAxisLabel = document.querySelector("#y-axis-label");
                if (yAxisLabel) {
                  yAxisLabel.innerHTML = searchTextEl2.value + " →";
                  yAxisLabel.className = "axis-label";
                }





  // Now make svg

          const images = svg
            .selectAll("image")
            .data(imageData)
            .join("image")
            // .attr("href", d => d.url)
            .attr("x", d => d.x)
            .attr("y", d =>  d.y)
            .attr("width", imSize)
            .attr("height", imSize)
            .on('click', function(event, d) { console.log(d.url); window.open(d.url, '_blank'); })
            // .on('mouseover', function(event, d) {
            //       // Add a tooltip to show the image title when hovering
            //       d3.select('#tooltip')
            //         .style('left', (event.pageX + 10) + 'px')
            //         .style('top', (event.pageY + 10) + 'px')
            //         .text(d.title )
            //         .classed('hidden', false);
            //     })
            //     .on('mouseout', function(event) {
            //       // Hide the tooltip when no longer hovering
            //       d3.select('#tooltip').classed('hidden', true);
            //     })   
                .each(async function(d, i, nodes) {
                  // if lots of images, dont make thumbnails
                if(imageData.length < 2000){
            thumbnailBlob = await getThumbnail(d.url);
            thumbnailUrl = URL.createObjectURL(thumbnailBlob);
          } else{
            thumbnailUrl = d.url
          }
          
    d3.select(nodes[i]).attr('href', thumbnailUrl);
    if (i === nodes.length - 1) {
      requestAnimationFrame(() => {
        svg.node().dispatchEvent(new Event('redraw'));
      });
    }
  })
  .on('load', function() {document.getElementById("searchSpinner").style.display = "none";})


              // Just in case we are rerunning this without clicking checkbox, do the above
              if (forceDirected.property("checked")) {
                images.attr("x", d => d.force_x)
                      .attr("y", d => d.force_y);
              } else {
                images.attr("x", d => d.orig_x)
                      .attr("y", d => d.orig_y);
              }


        // Add a hidden tooltip element to the body
        // d3.select('body')
        //   .append('div')
        //   .attr('id', 'tooltip')
        //   .classed('hidden', true);


      // get the extent of the x and y values in the data
      const xExtent = d3.extent(imageData, d => d.x);
      const yExtent = d3.extent(imageData, d => d.y);

      const margin = 50;

      // set the translate extent to the full extent of the data
      const translateExtent = [
        [xExtent[0]-margin, yExtent[0]-margin],
        [xExtent[1]+margin, yExtent[1]+margin]
      ];



            const zoom = d3.zoom()
                // .extent([[(-width/2), (-height/2)], [width*1.5, height*1.5]])
                .scaleExtent([.5, 10])
               .translateExtent(translateExtent)
                .on("zoom", handleZoom);

              svg.call(zoom);

              function handleZoom(event) {
                images.attr("transform", event.transform);
                // circles.attr("transform", event.transform);
              }



        
        if(!resultHtml) {
          resultsEl.innerHTML = "No results found after filtering NSFW.";
        } else {
          resultsEl.innerHTML = resultHtml;
        }
        
        searchBtn.disabled = false;
        // searchSpinner hide
      }


      // Hide toolbar when not in use
      const checkbox = document.getElementById('hideToolbar')

          checkbox.addEventListener('change', (event) => {
            if (event.currentTarget.checked) {
              // alert('checked');
              document.documentElement.style.setProperty('--hide-opacity', '0');
            } else {
              // alert('not checked');
              // Remove "extrahide" class to step2
              document.documentElement.style.setProperty('--hide-opacity', '0.3');
            }
          })




      /////////////////////////////
      //  FUNCTIONS / UTILITIES  //
      /////////////////////////////


      function clearD3(){
        d3.select("svg").remove();
      }

      async function getThumbnail(url) {
  const maxDimension = 512;
  const response = await fetch(url);
  const blob = await response.blob();
  const image = await createImageBitmap(blob);
  const { width, height } = image;
  const canvas = new OffscreenCanvas(width, height);
  const context = canvas.getContext('2d');
  context.drawImage(image, 0, 0);
  let thumbnailWidth = width;
  let thumbnailHeight = height;
  if (thumbnailWidth > maxDimension) {
    thumbnailWidth = maxDimension;
    thumbnailHeight = Math.round(height * maxDimension / width);
  }
  if (thumbnailHeight > maxDimension) {
    thumbnailHeight = maxDimension;
    thumbnailWidth = Math.round(width * maxDimension / height);
  }
  const thumbnailCanvas = new OffscreenCanvas(thumbnailWidth, thumbnailHeight);
  const thumbnailContext = thumbnailCanvas.getContext('2d');
  thumbnailContext.drawImage(canvas, 0, 0, width, height, 0, 0, thumbnailWidth, thumbnailHeight);
  const thumbnailBlob = await thumbnailCanvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
  return thumbnailBlob;
}


      async function getFileHandleByPath(path) {
        let handle = directoryHandle;
        let chunks = path.split("/").slice(1);
        for(let i = 0; i < chunks.length; i++) {
          let chunk = chunks[i];
          if(i === chunks.length-1) {
            handle = await handle.getFileHandle(chunk);
          } else {
            handle = await handle.getDirectoryHandle(chunk);
          }
        }
        return handle;
      }
      
      async function getRgbData(blob) { 
        // let blob = await fetch(imgUrl, {referrer:""}).then(r => r.blob());

        let resizedBlob = await bicubicResizeAndCenterCrop(blob);
        let img = await createImageBitmap(resizedBlob);

        let oscanvas = new OffscreenCanvas(224, 224);
        let ctx = oscanvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        let imageData = ctx.getImageData(0, 0, oscanvas.width, oscanvas.height);

        let rgbData = [[], [], []]; // [r, g, b]
        // remove alpha and put into correct shape:
        let d = imageData.data;
        for(let i = 0; i < d.length; i += 4) { 
          let x = (i/4) % oscanvas.width;
          let y = Math.floor((i/4) / oscanvas.width)
          if(!rgbData[0][y]) rgbData[0][y] = [];
          if(!rgbData[1][y]) rgbData[1][y] = [];
          if(!rgbData[2][y]) rgbData[2][y] = [];
          rgbData[0][y][x] = d[i+0]/255;
          rgbData[1][y][x] = d[i+1]/255;
          rgbData[2][y][x] = d[i+2]/255;
          // From CLIP repo: Normalize(mean=(0.48145466, 0.4578275, 0.40821073), std=(0.26862954, 0.26130258, 0.27577711))
          rgbData[0][y][x] = (rgbData[0][y][x] - 0.48145466) / 0.26862954;
          rgbData[1][y][x] = (rgbData[1][y][x] - 0.4578275) / 0.26130258;
          rgbData[2][y][x] = (rgbData[2][y][x] - 0.40821073) / 0.27577711;
        }
        rgbData = Float32Array.from(rgbData.flat().flat());
        return rgbData;
      }
      
      async function bicubicResizeAndCenterCrop(blob) {
        let im1 = vips.Image.newFromBuffer(await blob.arrayBuffer());

        // Resize so smallest side is 224px:
        const scale = 224 / Math.min(im1.height, im1.width);
        let im2 = im1.resize(scale, { kernel: vips.Kernel.cubic });

        // crop to 224x224:
        let left = (im2.width - 224) / 2;
        let top = (im2.height - 224) / 2;
        let im3 = im2.crop(left, top, 224, 224)

        let outBuffer = new Uint8Array(im3.writeToBuffer('.png'));
        im1.delete(), im2.delete(), im3.delete();
        return new Blob([outBuffer], { type: 'image/png' });
      }


      function downloadBlobWithProgressOld(url, onProgress) {
        return new Promise((res, rej) => {
          var blob;
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = function(e) {
            blob = new Blob([this.response]);   
          };
          xhr.onprogress = onProgress;
          xhr.onloadend = function(e){
            res(blob);
          }
          xhr.send();
        });
      }


      function downloadBlobWithProgress(url, onProgress) {
  return new Promise((res, rej) => {
    const filename = url.substring(url.lastIndexOf('/')+1);
    const dbRequest = window.indexedDB.open('myDatabase', 1);
    dbRequest.onerror = rej;
    dbRequest.onupgradeneeded = function(event) {
      const db = event.target.result;
      db.createObjectStore('files');
    };
    dbRequest.onsuccess = function(event) {
      const db = event.target.result;
      const tx = db.transaction(['files'], 'readonly');
      const store = tx.objectStore('files');
      const getRequest = store.get(filename);
      getRequest.onsuccess = function(event) {
        const fileData = event.target.result;
        if (fileData) {
          // file already exists in IndexedDB, load from dataURL
          const blob = dataURLToBlob(fileData);
          res(blob);
        } else {
          // file does not exist in IndexedDB, download and save
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'blob';
          xhr.onload = function(e) {
            const blob = this.response;
            const reader = new FileReader();
            reader.onloadend = function() {
              const tx = db.transaction(['files'], 'readwrite');
              const store = tx.objectStore('files');
              store.put(reader.result, filename);
            };
            reader.readAsDataURL(blob);
            res(blob);
          };
          xhr.onprogress = onProgress;
          xhr.onerror = rej;
          xhr.send();
        }
      };
    };
  });
}

function dataURLToBlob(dataURL) {
  const arr = dataURL.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while(n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], {type:mime});
}
// end of IndexedDB code

      async function saveEmbeddings(opts={}) {
        let writable = await embeddingsFileHandle.createWritable();
        let textBatch = "";
        let i = 0;
        for(let [filePath, embeddingVec] of Object.entries(embeddings)) {
          let vecString = opts.compress ? JSON.stringify(embeddingVec.map(n => n.toFixed(3))).replace(/"/g, "") : JSON.stringify(embeddingVec);
          textBatch += `${filePath}\t${vecString}\n`;
          i++;
          if(i % 1000 === 0) {
            await writable.write(textBatch);
            textBatch = "";
          }
        }
        await writable.write(textBatch);
        await writable.close();
      }
      
      // Tweaked version of example from here: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/read
      async function* makeTextFileLineIterator(blob, opts={}) {
        const utf8Decoder = new TextDecoder("utf-8");
        let stream = await blob.stream();
        
        if(opts.decompress === "gzip") stream = stream.pipeThrough(new DecompressionStream("gzip"));
        
        let reader = stream.getReader();
        
        let {value: chunk, done: readerDone} = await reader.read();
        chunk = chunk ? utf8Decoder.decode(chunk, {stream: true}) : "";

        let re = /\r\n|\n|\r/gm;
        let startIndex = 0;

        while (true) {
          let result = re.exec(chunk);
          if (!result) {
            if (readerDone) {
              break;
            }
            let remainder = chunk.substr(startIndex);
            ({value: chunk, done: readerDone} = await reader.read());
            chunk = remainder + (chunk ? utf8Decoder.decode(chunk, {stream: true}) : "");
            startIndex = re.lastIndex = 0;
            continue;
          }
          yield chunk.substring(startIndex, result.index);
          startIndex = re.lastIndex;
        }
        if (startIndex < chunk.length) {
          // last line didn't end in a newline char
          yield chunk.substr(startIndex);
        }
      }

      function cosineSimilarity(A, B) {
        if(A.length !== B.length) throw new Error("A.length !== B.length");
        let dotProduct = 0, mA = 0, mB = 0;
        for(let i = 0; i < A.length; i++){
          dotProduct += A[i] * B[i];
          mA += A[i] * A[i];
          mB += B[i] * B[i];
        }
        mA = Math.sqrt(mA);
        mB = Math.sqrt(mB);
        let similarity = dotProduct / (mA * mB);
        return similarity;
      }

      function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
      }

      function enableCtn(el) {
        el.style.opacity = 1;
        el.style.pointerEvents = "";
      }
      function disableCtn(el) {
        el.style.opacity = 0.5;
        el.style.pointerEvents = "none";
      }


      function getCSV() {
  // We want 3 columns to our CSV: filename, prompt1 (score), and prompt 2 (score2).
  // searchtextel
  const prompt1 = document.getElementById('searchTextEl').value;
  const prompt2 = document.getElementById('searchTextEl2').value;
  let csv = 'Image,' + prompt1 + ',' + prompt2 + '\n';

  // Iterate through the d3 data and add a row for each file, with d.score and d.score2 
  // as the prompt1 and prompt2 scores.
  for (let i = 0; i < imageResults.length; i++) {
    const d = imageResults[i];
    // Strip any commas from d.path 
    const path = d.path.replace(/,/g, '');
    csv += path + ',' + d.score + ',' + d.score2 + '\n';
  }

  // Create a Blob object from the CSV data.
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });

  // Create a URL for the Blob object using the createObjectURL() method.
  const url = URL.createObjectURL(blob);

  // Create a link element and set its attributes.
  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', '2DCLIP.csv');

  // Trigger a click event on the link element to download the CSV file.
  link.click();
}

      

      // From the PyTorch model running on CUDA:
      // Text: "a portrait of an astronaut with the American flag" 
      // Embedding: [-1.6626e-01,  5.2277e-02, -1.5332e-01,  4.4946e-01,  2.0667e-01, -2.9565e-01,  4.0588e-02, -4.1016e-01, -1.5027e-01,  3.1934e-01, -6.9702e-02, -2.5488e-01,  1.2335e-01, -9.5337e-02,  2.4109e-01, -4.8950e-02,  2.6074e-01,  5.3835e-04,  2.1033e-01,  3.7012e-01, 4.5679e-01,  3.9795e-01,  3.1641e-01,  3.9551e-01,  1.3931e-02, -4.3060e-02,  4.8798e-02,  3.7158e-01,  1.1731e-01, -3.7256e-01, -2.7295e-01,  3.3130e-01,  5.4980e-01, -2.9816e-02, -2.5806e-01, -1.0016e-01,  8.0750e-02, -6.7139e-02, -2.4072e-01,  2.4353e-01, -3.2202e-01, -1.0327e-01,  1.1566e-01,  6.2646e-01,  1.8262e-01, 2.7539e-01, -1.1816e-01,  4.9512e-01,  8.9539e-02,  5.6299e-01, 2.1313e-01, -1.5625e-01,  1.9958e-01, -5.0049e-01, -2.5854e-01, -4.0430e-01, -1.1298e-01, -6.6338e-03,  2.5391e-01, -5.0629e-02, 2.2253e-01, -2.7295e-01, -5.8289e-03, -4.8804e-01, -7.7820e-02, -3.5187e-02, -3.7537e-02,  4.3213e-01,  3.8300e-02,  2.1045e-01, -3.0347e-01, -9.8999e-02, -1.7407e-01,  2.8882e-01,  1.1322e-01, -1.0883e-01,  1.7065e-01, -2.1191e-01,  1.7920e-01, -1.2805e-01, -4.6924e-01,  1.1957e-01, -1.1829e-01, -1.1902e-01, -2.4353e-01, -9.6008e-02,  2.2913e-01, -1.0948e-02, -1.5686e-01, -2.0483e-01, -2.4756e-01,  9.1125e-02, -9.5557e-01, -4.2511e-02,  4.6356e-02, 4.3481e-01,  2.3633e-01, -3.3252e-01,  3.7231e-01, -5.5695e-02, 7.1777e-02, -1.0370e-01, -2.1912e-01, -1.3733e-01,  1.2048e-01, 1.7151e-01, -1.2659e-01,  2.3523e-01,  2.6001e-01, -4.0381e-01, 1.1761e-01, -4.1626e-02,  1.0974e-01, -5.5206e-02,  4.9713e-02, 5.2197e-01,  3.9124e-02,  5.7959e-01,  9.9609e-02, -3.3740e-01, -2.7295e-01, -7.3389e-01,  1.0962e-01, -3.2178e-01,  6.5869e-01, 2.3460e-03,  2.6733e-02,  3.2471e-02, -2.4500e-01,  7.9041e-02, 1.5405e-01, -3.5547e-01, -1.5625e-01,  4.2695e+00, -1.6113e-01, 1.6467e-01, -3.8794e-01,  2.1545e-02,  1.5771e-01,  2.0068e-01, -3.4741e-01,  2.5244e-01,  1.2201e-01, -3.9795e-02,  3.2471e-01, 2.6562e-01,  1.2915e-01,  1.4465e-02, -2.1265e-01, -2.5055e-02, 5.6689e-01, -6.5125e-02,  1.1652e-01, -5.1025e-01,  1.0712e-01, 8.8867e-02,  1.6882e-01, -6.5125e-02,  4.5929e-02,  2.9517e-01, 6.5479e-01, -9.0881e-02, -4.6417e-02, -3.0713e-01, -5.1537e-03, 4.9390e-01,  5.4492e-01, -3.1812e-01, -6.0577e-02,  3.6591e-02, 7.6782e-02, -3.5181e-01,  4.9487e-01, -4.1040e-01,  4.3970e-01, 1.6553e-01, -3.7329e-01,  3.3594e-01, -1.9263e-01, -1.8225e-01, -1.9623e-02, -4.0454e-01,  1.6187e-01,  1.5259e-01,  2.5122e-01, 1.1993e-01, -8.4595e-02, -4.1016e-01, -1.8225e-01,  1.8555e-01, -3.9124e-02,  2.5122e-01, -2.2949e-01,  5.3125e-01, -1.0504e-01, -2.1439e-02, -2.2559e-01,  5.9357e-02, -3.9160e-01, -3.3716e-01, -9.0393e-02, -1.7493e-01, -2.5952e-01,  2.3401e-01,  3.8013e-01, 1.2927e-01,  1.5491e-01,  1.1920e-01, -1.5906e-01,  5.7487e-03, 7.6172e-02,  1.5552e-01,  2.1790e-01,  9.9304e-02, -3.8025e-02, -1.1829e-01, -1.3293e-01, -2.2278e-01, -2.1472e-01,  3.0957e-01, -1.0254e-01, -2.0264e-01, -2.6840e-02,  8.8379e-02, -8.2092e-02, 1.3647e-01, -2.1399e-01, -2.5684e-01,  1.3745e-01,  6.1371e-02, -1.2988e-01,  6.2683e-02,  1.2964e-01, -3.3112e-02,  1.4111e-01, -2.6440e-01,  4.7379e-03, -1.0815e-01, -4.4971e-01, -3.5583e-02, 1.1469e-01,  6.7871e-02, -5.8350e-02,  1.0297e-01, -6.3086e-01, -8.3350e-01,  4.3481e-01, -1.7383e-01, -1.5491e-01, -5.5176e-01, 5.9766e-01, -2.6880e-01,  5.6976e-02, -2.6318e-01, -4.0466e-02, 2.4927e-01, -1.4893e-01, -2.0032e-01, -2.7515e-01, -1.2598e-01, 3.2440e-02, -1.2939e-01,  6.8018e-01, -3.6060e-01, -3.3496e-01, 9.8267e-02, -1.0010e-01,  1.9653e-01, -3.3032e-01, -2.0032e-01, 1.9116e-01,  8.2214e-02,  3.2397e-01,  1.3708e-01,  3.0899e-02, 1.5454e-01,  3.2422e-01,  1.0693e-01,  3.1714e-01,  3.7280e-01, -2.3401e-01, -5.0171e-02,  7.6758e-01,  2.2046e-01,  3.3997e-02, 1.0231e-02, -2.3999e-01, -1.3672e-01,  5.2002e-01, -6.5552e-02, 6.9275e-02,  2.3706e-01, -3.8257e-01,  1.4990e-01, -2.2656e-01, 4.3018e-01, -4.4678e-01,  2.5977e-01,  3.8208e-01,  9.5215e-02, -2.0239e-01, -2.3169e-01, -3.1396e-01,  3.2806e-02, -2.7905e-01, -1.0361e+00,  3.8147e-02, -1.0278e-01,  2.8369e-01, -3.8623e-01, -2.3132e-01,  1.5784e-01,  4.2734e+00, -1.5820e-01, -1.4758e-01, 2.0032e-01, -1.9678e-01, -7.5586e-01,  1.0712e-01, -2.1777e-01, -4.0552e-01, -1.0919e-01,  1.1932e-01,  7.3486e-01, -1.7700e-01, 5.0732e-01, -9.7351e-02, -4.7192e-01,  5.9052e-02, -7.0117e-01, -1.8774e-01,  2.4329e-01,  3.5083e-01, -2.3633e-01,  2.2205e-01, -2.4719e-03,  4.4507e-01, -1.1005e-01,  5.6494e-01, -1.4697e-01, -8.5022e-02, -2.6050e-01, -8.3679e-02,  3.0615e-01,  1.0181e-01, -2.2266e-01, -1.2054e-01,  1.0094e-02, -1.6382e-01,  3.7671e-01, 1.1371e-01,  8.8959e-03, -1.2866e-01,  7.5500e-02, -3.1177e-01, 9.0698e-02,  2.4139e-02,  2.7124e-01,  4.1382e-01,  9.3872e-02, -3.5815e-01, -1.0602e-01, -2.7637e-01,  1.5613e-01,  2.6025e-01, -1.3428e-01, -2.1509e-01, -3.0005e-01,  7.7515e-02, -2.2253e-01, -1.2634e-01,  1.0114e-01,  2.9395e-01,  4.2065e-01, -4.6425e-03, -6.3721e-01, -4.0308e-01, -5.1849e-02, -9.1309e-02,  1.0577e-01, -1.6800e-02, -4.4823e-03,  2.4231e-01, -1.3635e-01,  1.7041e-01, -9.9243e-02, -1.2439e-01,  1.5247e-01,  1.4717e-02, -1.6785e-01, -3.0615e-01,  2.6074e-01,  1.0938e-01,  4.9487e-01,  1.0529e-01, 3.1799e-02,  7.5928e-02, -1.1212e-01, -3.1201e-01,  5.8740e-01, -1.3171e-01, -1.1090e-01,  5.8887e-01, -1.1420e-01, -2.0056e-01, 1.0425e-01,  2.7710e-01, -5.8098e-03,  5.7324e-01, -1.4417e-01, 1.4575e-01, -2.7466e-01, -2.1313e-01, -1.7627e-01,  1.5466e-01, 3.8013e-01, -1.4612e-01, -2.7246e-01, -1.8604e-01,  1.0394e-01, 1.6016e-01, -1.1017e-01,  1.8140e-01, -3.0078e-01,  6.0303e-01, -1.3904e-01,  1.7322e-01,  2.2510e-01,  2.3303e-01, -5.0879e-01, -2.3462e-01, -2.0544e-01, -2.4768e-01, -2.4121e-01, -7.2754e-01, 7.2754e-01, -4.4312e-02, -1.4198e-02, -1.1475e-01, -1.3684e-01, -3.5278e-01,  1.2347e-01, -2.9602e-02,  4.0550e-03,  1.1951e-01, -6.5575e-03, -7.1228e-02, -3.8062e-01,  6.5125e-02, -1.6541e-01, -3.0289e-02,  8.6609e-02, -1.2134e-01, -1.2164e-01,  3.0319e-02, -1.5173e-01, -7.9834e-02,  1.4148e-01,  2.7319e-01, -2.1545e-01, -1.6382e-01, -2.9419e-01, -2.6611e-01, -7.5102e-04,  1.3135e-01, 9.8389e-02,  3.1812e-01,  5.5115e-02, -5.3253e-02,  4.3823e-02, 3.6957e-02, -1.3599e-01,  1.1023e-01,  9.8267e-02,  2.1643e-01, 9.3567e-02,  1.2718e-02,  1.6406e-01, -1.0338e-02,  1.9019e-01, 1.4392e-01,  3.3081e-02,  1.0138e-01, -1.6943e-01,  8.6136e-03, 1.4478e-01,  1.0941e-02,  1.3635e-01, -8.1543e-01, -3.4912e-01, 7.4959e-03,  2.1997e-01, -2.5681e-02,  2.3206e-01,  3.7622e-01, 3.6401e-01, -1.6357e-01, -2.0984e-01, -1.3220e-01, -6.7322e-02, 2.0117e-01, -4.7583e-01,  6.8054e-02,  2.2437e-01,  2.6709e-01, -5.4626e-02, -4.0741e-02,  5.2002e-02, -1.8872e-01,  3.1372e-01, -1.3574e-01, -2.6538e-01];
    </script>
  </body>
</html>
